/*! For license information please see 061797e6.480be039.js.LICENSE.txt */
"use strict";(self.webpackChunkbackstage_microsite=self.webpackChunkbackstage_microsite||[]).push([[656576],{221296:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>i,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>d});var n=t(785893),o=t(511151);const r={id:"backend-tasks.taskscheduledefinition.scope",title:"TaskScheduleDefinition.scope",description:"API reference for TaskScheduleDefinition.scope"},c=void 0,a={id:"reference/backend-tasks.taskscheduledefinition.scope",title:"TaskScheduleDefinition.scope",description:"API reference for TaskScheduleDefinition.scope",source:"@site/versioned_docs/version-stable/reference/backend-tasks.taskscheduledefinition.scope.md",sourceDirName:"reference",slug:"/reference/backend-tasks.taskscheduledefinition.scope",permalink:"/docs/reference/backend-tasks.taskscheduledefinition.scope",draft:!1,unlisted:!1,editUrl:"https://github.com/backstage/backstage/edit/master/docs/versioned_docs/version-stable/reference/backend-tasks.taskscheduledefinition.scope.md",tags:[],version:"stable",frontMatter:{id:"backend-tasks.taskscheduledefinition.scope",title:"TaskScheduleDefinition.scope",description:"API reference for TaskScheduleDefinition.scope"}},i={},d=[{value:"Remarks",id:"remarks",level:2}];function l(e){const s={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,o.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.a,{href:"/docs/reference/",children:"Home"})," > ",(0,n.jsx)(s.a,{href:"/docs/reference/backend-tasks",children:(0,n.jsx)(s.code,{children:"@backstage/backend-tasks"})})," > ",(0,n.jsx)(s.a,{href:"/docs/reference/backend-tasks.taskscheduledefinition",children:(0,n.jsx)(s.code,{children:"TaskScheduleDefinition"})})," > ",(0,n.jsx)(s.a,{href:"/docs/reference/backend-tasks.taskscheduledefinition.scope",children:(0,n.jsx)(s.code,{children:"scope"})})]}),"\n",(0,n.jsx)(s.p,{children:"Sets the scope of concurrency control / locking to apply for invocations of this task."}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.strong,{children:"Signature:"})}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-typescript",children:"scope?: 'global' | 'local';\n"})}),"\n",(0,n.jsx)(s.h2,{id:"remarks",children:"Remarks"}),"\n",(0,n.jsxs)(s.p,{children:["When the scope is set to the default value ",(0,n.jsx)(s.code,{children:"'global'"}),", the scheduler will attempt to ensure that only one worker machine runs the task at a time, according to the given cadence. This means that as the number of worker hosts increases, the invocation frequency of this task will not go up. Instead, the load is spread randomly across hosts. This setting is useful for tasks that access shared resources, for example catalog ingestion tasks where you do not want many machines to repeatedly import the same data and trample over each other."]}),"\n",(0,n.jsxs)(s.p,{children:["When the scope is set to ",(0,n.jsx)(s.code,{children:"'local'"}),", there is no concurrency control across hosts. Each host runs the task according to the given cadence similarly to ",(0,n.jsx)(s.code,{children:"setInterval"}),", but the runtime ensures that there are no overlapping runs."]})]})}function h(e={}){const{wrapper:s}={...(0,o.a)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},675251:(e,s,t)=>{var n=t(667294),o=Symbol.for("react.element"),r=Symbol.for("react.fragment"),c=Object.prototype.hasOwnProperty,a=n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,i={key:!0,ref:!0,__self:!0,__source:!0};function d(e,s,t){var n,r={},d=null,l=null;for(n in void 0!==t&&(d=""+t),void 0!==s.key&&(d=""+s.key),void 0!==s.ref&&(l=s.ref),s)c.call(s,n)&&!i.hasOwnProperty(n)&&(r[n]=s[n]);if(e&&e.defaultProps)for(n in s=e.defaultProps)void 0===r[n]&&(r[n]=s[n]);return{$$typeof:o,type:e,key:d,ref:l,props:r,_owner:a.current}}s.Fragment=r,s.jsx=d,s.jsxs=d},785893:(e,s,t)=>{e.exports=t(675251)},511151:(e,s,t)=>{t.d(s,{Z:()=>a,a:()=>c});var n=t(667294);const o={},r=n.createContext(o);function c(e){const s=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),n.createElement(r.Provider,{value:s},e.children)}}}]);